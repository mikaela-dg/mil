#!/usr/bin/env python
import rospy
import numpy as np
from rospy.numpy_msg import numpy_msg
from std_msgs.msg import Header
from mil_passive_sonar.msg import HydrophoneSamples
from mil_ros_tools import Plotter

from scipy.fftpack import rfft
from scipy.signal import remez, fftconvolve, correlate
from scipy.ndimage.filters import maximum_filter1d


class HydrophoneTrigger:

    def __init__(self):
        #  Ros stuff
        rospy.init_node('hydrophone_trigger')
        self.sub = rospy.Subscriber('/samples', numpy_msg(HydrophoneSamples), self.hydrophones_cb)
        self.pub = rospy.Publisher('/pings', numpy_msg(HydrophoneSamples), queue_size=1)

        # Attriburtes about our general frequency range (all pinger live here)
        #  Frequency range garunteed to be relatively quiet except for the pingers (in Hz)
        self.general_lower = 15000 # lowest frequency pinger - 10 kHz
        self.general_upper = 50000 # highest frequency pinger + 10 kHz

        # Attributes about our target frequency range (one pinger live here at a time)
        #  Target Frquency we are looking for in Hz
        self.target_frequency = 35000
        #  Tolerance around that frequency in Hz
        self.target_frequency_tol = 500

        # Filter attributes
        #  Filter order for bandpass filter, (higher is better, but slower to compute)
        self.filt_order = 201
        #  Filter used to do a band pass filter for our target frquency range, calcuated on first cb
        self.bandpass_filter = None
        #  special filter property, do not change in Hz
        self.trans_width = 1000

        # Physical Properties
        #  speed of sound in water in m/s
        self.speed_of_sound = 1498
        # min time between pings in sec
        self.min_time_between_pings = 0.25
        self.prev_trigger_time = -self.min_time_between_pings

        # Debug attributes
        #  Debug plot publishers
        self.fft_debug = Plotter('fft_debug')
        self.fft_debug.enabled = False
        self.trigger_debug = Plotter('trigger_debug')
        self.sample_at_trigger_debug = Plotter('sample_at_trigger_debug')

        # Misc attributes
        #  minimum gradient of the max convolution wrt time to trigger a time of arivals calcualtion
        self.threshold = 40
        #  expected error in determining exactly when the triggering happend (after) in sec
        self.trigger_time_error_future = 0.0003
        #  expected error in determining exactly when the triggering happend (before) in sec
        self.trigger_time_error_past = 0.0003
        # time (from start of samples)
        self.time = 0.0
        # max convolution window, the amount of time that we assume should be quiet before a ping in sec
        self.window_time = 100e-3
        #  prev data buffer
        self.prev_data = None



    def col_wise_normalization(self, data):
        data = data - np.mean(data, axis=0).transpose()
        data = data / np.std(data,axis=0).transpose()
        return data


    def make_bandpass_filter(self, rate):
        # Make a bandpass for out target freq range
        self.bandpass_filter = remez(self.filt_order,
            [0, self.general_lower - self.trans_width,
             self.general_lower, self.general_upper,
             self.general_upper + self.trans_width, rate/2], [0,1,0], Hz = rate)


    def interweave(self, x, ys):
        # put x in every other col of the ys (used for plotting)
        plots = [None] * ys.shape[1]
        for i in xrange(ys.shape[1]):
            plots[i] = np.vstack((x, ys[:,i]))
        plots = np.vstack(tuple(plots))
        return plots


    def hydrophones_cb(self, msg):
        # Record start time of cb to make sure we are running in real time
        start_cb = rospy.get_rostime()
        # Resize the 1d array to be a 2d array of samples by channels
        msg.data.resize(msg.samples, msg.channels)

        # If no bandpass yet, make a bandpass (sample rate not expected to change)
        if self.bandpass_filter is None:
            self.make_bandpass_filter(msg.sample_rate)

        # Apply a bandpass filter to the data for our target frequency range (on all channels)
        new_data = np.apply_along_axis(lambda x: fftconvolve(x, self.bandpass_filter, 'valid'),
            0, msg.data)

        # We always look at 2 messages of data at a time concatenated (0.1 sec each msg (for sylphase board))
        if self.prev_data is None:
            self.prev_data = new_data
            return
        else:
            data = np.concatenate((self.prev_data, new_data))
        # Time according to the passive sonar interface (assuming no missed messages)
        time = np.linspace(self.time, self.time + data.shape[0]/float(msg.sample_rate),
            data.shape[0])

        window_size = int(self.window_time * msg.sample_rate)

        # only use hydrophone 0 to trigger, more efficient
        # do a max convolution on the data
        max_convolve = maximum_filter1d(data[:,0], window_size, axis=0)\
                           [(window_size-1) - (window_size-1)/2 : data.shape[0] - (window_size-1)/2]
                           # removes values influenced by padding

        # crop time to reflect the times we actually have data for (offest by +(window_size-1)/2
        #  because the convolution output is from the center of the window, not the right side of the window
        time = time[(window_size-1): data.shape[0]]
        # crop data in the same way for the same reason
        data = data[(window_size-1): data.shape[0]]
        # take the gradient of the max convolution (we are looking for steep increase = big gradient)
        gradient = np.gradient(max_convolve, axis=0)

        if self.trigger_debug.is_go():
            plot_data = data[:,0]
            titles = ['time vs Gradient of Max convolve',
                      'time vs max_convolve (Window = %s sec)'%self.window_time,
                      'time vs hydrophone0 data']
            plotable = np.vstack((gradient, max_convolve, plot_data)).transpose()
            plots = self.interweave(time, plotable)
            self.trigger_debug.publish_plots(plots, titles)

        if np.max(gradient) >= self.threshold:
            triggered_at_idx = np.min(np.where(gradient >= self.threshold)[0])
            trigger_time = time[triggered_at_idx]

            # if we have triggered very recently, do not trigger (echo protection)
            if trigger_time - self.prev_trigger_time > self.min_time_between_pings:

                rospy.loginfo('triggered at %f'%trigger_time)

                self.prev_trigger_time = trigger_time

                start = triggered_at_idx - int(msg.sample_rate*self.trigger_time_error_past)
                end = triggered_at_idx + int(msg.sample_rate*self.trigger_time_error_future)

                ping_data = data[start:end]

                ping = HydrophoneSamples()
                ping.header = Header()
                ping.header.stamp = rospy.Time.now()
                ping.channels = msg.channels
                ping.samples = end - start
                ping.sample_rate = msg.sample_rate
                ping.data = ping_data

                self.pub.publish(ping)

                if self.sample_at_trigger_debug.is_go():
                    plot_time = time[start:end]
                    plots = self.interweave(plot_time, ping_data)
                    self.sample_at_trigger_debug.publish_plots(plots)

        if self.fft_debug.is_go():
            # Do a Fourier transform on all the channels
            ffts = rfft(data, axis=0)

            # Normalize the FFT (Gaussian)
            ffts = self.col_wise_normalization(ffts)
            # make the ffts absolute value for easier math later
            ffts = np.absolute(ffts)

            # Crop the FFT for our general frequency range
            res = float(ping.sample_rate) / ping.samples
            ffts = ffts[int((self.general_lower+5000)/res):int((self.general_upper-5000)/res)]
            freq = np.arange((self.general_lower+5000)/res, (self.general_upper-5000)/res)*res

            # Debug publish the FFTs of all hydrophones of the debuggies
            plots = self.interweave(freq, ffts)
            self.fft_debug.publish_plots(plots)

        self.time += msg.samples / float(msg.sample_rate)
        self.prev_data = new_data

        spare_time = (float(msg.samples) / msg.sample_rate) - (rospy.get_rostime() - start_cb).to_sec()

        if spare_time < 0:
            rospy.loginfo('Spare Time After Callback %f'%spare_time)


if __name__ == '__main__':
    a = HydrophoneTrigger()
    rospy.spin()


